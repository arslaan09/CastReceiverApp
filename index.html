o<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Screen Mirror Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    #splash {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
    }

    .logo {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 40px;
      box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
      animation: pulse 2s ease-in-out infinite;
    }

    .logo svg {
      width: 60px;
      height: 60px;
      fill: white;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }
    }

    .title {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 15px;
    }

    .subtitle {
      font-size: 24px;
      opacity: 0.8;
      margin-bottom: 50px;
    }

    .status-container {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 20px 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .status-dot {
      width: 12px;
      height: 12px;
      background: #fbbf24;
      border-radius: 50%;
      animation: blink 1.5s ease-in-out infinite;
    }

    .status-dot.connected {
      background: #4ade80;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.4;
      }
    }

    .status-text {
      font-size: 20px;
    }

    #video-player {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
      display: none;
      z-index: 5;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div id="splash">
    <div class="logo">
      <svg viewBox="0 0 24 24">
        <path
          d="M21,3H3C1.89,3 1,3.89 1,5V17A2,2 0 0,0 3,19H8V21H16V19H21A2,2 0 0,0 23,17V5C23,3.89 22.1,3 21,3M21,17H3V5H21M16,11L9,15V7" />
      </svg>
    </div>
    <div class="title">Screen Mirroring -Miracast</div>
    <div class="subtitle" id="connectionMessage">Waiting for connection...</div>
    <div class="status-container">
      <div class="status-dot" id="statusDot"></div>
      <div class="status-text" id="statusText">Ready to receive</div>
    </div>
  </div>

  <video id="video-player" autoplay playsinline muted></video>
  <img id="mjpeg-viewer" class="hidden"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 5; background: black; will-change: contents; transform: translateZ(0); image-rendering: auto;">
  <video id="media-player" class="hidden" playsinline preload="auto"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 7; background: black;"></video>
  <img id="image-viewer" class="hidden"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 6; background: black;">

  <script>
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();

    const splash = document.getElementById('splash');
    const videoPlayer = document.getElementById('video-player');
    const mjpegViewer = document.getElementById('mjpeg-viewer');
    const mediaPlayer = document.getElementById('media-player');
    const imageViewer = document.getElementById('image-viewer');
    const castMediaPlayer = document.getElementById('cast-media-player');
    const connectionMessage = document.getElementById('connectionMessage');
    const statusText = document.getElementById('statusText');
    const statusDot = document.getElementById('statusDot');

    const NAMESPACE = 'urn:x-cast:com.tvmirror.screenmirror';

    // ── Status reporting ──────────────────────────────────────────────
    // Send playback state back to the iOS sender so it can sync the local player.
    let statusInterval = null;

    function sendStatus(state) {
      try {
        const msg = {
          type: 'MEDIA_STATUS',
          state: state,
          currentTime: mediaPlayer.currentTime || 0,
          duration: (mediaPlayer.duration && isFinite(mediaPlayer.duration)) ? mediaPlayer.duration : 0
        };
        context.sendCustomMessage(NAMESPACE, undefined, msg);
      } catch (e) { /* sender may not be connected yet */ }
    }

    function startStatusReporting() {
      if (statusInterval) return;
      // Report position every second while playing so iOS can drift-correct
      statusInterval = setInterval(() => {
        if (!mediaPlayer.paused && !mediaPlayer.ended) {
          sendStatus('playing');
        }
      }, 1000);
    }

    function stopStatusReporting() {
      if (statusInterval) { clearInterval(statusInterval); statusInterval = null; }
    }

    // Wire up media player events → send status to iOS
    mediaPlayer.addEventListener('playing',  () => { sendStatus('playing');  startStatusReporting(); });
    mediaPlayer.addEventListener('pause',    () => { stopStatusReporting();  sendStatus('paused');   });
    mediaPlayer.addEventListener('waiting',  () => { sendStatus('buffering'); });
    mediaPlayer.addEventListener('ended',    () => { stopStatusReporting();  sendStatus('ended');    });
    mediaPlayer.addEventListener('error',    () => { stopStatusReporting();  sendStatus('idle');     });
    // Unmute after first frame arrives (Chromecast may require muted autoplay first)
    mediaPlayer.addEventListener('loadeddata', () => {
      console.log('[RECEIVER] loadeddata — unmuting');
      mediaPlayer.muted = false;
    });
    mediaPlayer.addEventListener('seeked', () => {
      sendStatus(mediaPlayer.paused ? 'paused' : 'playing');
    });

    // ── Custom message handler ────────────────────────────────────────
    context.addCustomMessageListener(NAMESPACE, (event) => {
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch (e) { return; }
      }
      console.log('[RECEIVER] Got message type=' + (data.type || '?'));

      if (data.type === 'CONNECTION_ESTABLISHED') {
        connectionMessage.textContent = 'Connected to ' + (data.deviceName || 'iOS Device');
        statusText.textContent = 'Connection established';
        statusDot.classList.add('connected');
      }

      if (data.type === 'START_MIRRORING') {
        stopAllMedia();
        if (data.streamUrl) startMirroring(data.streamUrl);
      }

      if (data.type === 'STOP_MIRRORING') stopMirroring();

      if (data.type === 'CAST_IMAGE_WS') {
        cleanupMirroringConnection();
        cleanupImageCastingWS();
        stopMediaCasting();
        startImageCastingWS(data.streamUrl);
        videoPlayer.style.display = 'none';
        imageViewer.classList.remove('hidden');
        imageViewer.style.display = 'block';
        statusText.textContent = 'Waiting for Image...';
      }

      if (data.type === 'CAST_VIDEO') {
        cleanupMirroringConnection();
        cleanupImageCastingWS();
        stopImageCasting();
        playMedia(data.videoUrl, data.autoplay !== false);  // default autoplay=true
        statusText.textContent = 'Video Loading...';
      }

      if (data.type === 'CAST_AUDIO') {
        cleanupMirroringConnection();
        cleanupImageCastingWS();
        stopImageCasting();
        playMedia(data.audioUrl, data.autoplay !== false);
        statusText.textContent = 'Audio Loading...';
      }

      if (data.type === 'MEDIA_CONTROL') handleMediaControl(data.command, data.value);

      if (data.type === 'SET_VOLUME') {
        const v = parseFloat(data.volume);
        if (!isNaN(v)) mediaPlayer.volume = Math.max(0, Math.min(1, v));
      }
    });

    // ── Media playback ────────────────────────────────────────────────
    var mediaRetryCount = 0;
    const MAX_MEDIA_RETRIES = 4;
    let mediaRetryTimer = null;

    function playMedia(url, autoplay) {
      console.log('[RECEIVER] playMedia called, url=' + url + ' autoplay=' + autoplay);
      mediaRetryCount = 0;
      attemptPlayMedia(url, autoplay);
    }

    function attemptPlayMedia(url, autoplay) {
      console.log('[RECEIVER] attemptPlayMedia attempt=' + (mediaRetryCount + 1));
      splash.classList.add('hidden');
      mediaPlayer.classList.remove('hidden');
      mediaPlayer.style.display = 'block';
      videoPlayer.style.display = 'none';

      stopStatusReporting();
      if (mediaRetryTimer) { clearTimeout(mediaRetryTimer); mediaRetryTimer = null; }

      // Remove old listeners to avoid duplicates
      mediaPlayer.oncanplay = null;
      mediaPlayer.onerror = null;

      // Set up success handler
      mediaPlayer.oncanplay = function () {
        console.log('[RECEIVER] canplay fired — video ready');
        mediaPlayer.oncanplay = null; // fire once
        statusText.textContent = 'Playing Video';
        if (autoplay) {
          const p = mediaPlayer.play();
          if (p) p.catch(function (e) {
            console.log('[RECEIVER] play() rejected: ' + e + ' — trying muted');
            mediaPlayer.muted = true;
            mediaPlayer.play().catch(function () { });
          });
        } else {
          mediaPlayer.pause();
          sendStatus('paused');
          statusText.textContent = 'Video Ready';
        }
      };

      // Set up error handler with retry
      mediaPlayer.onerror = function () {
        const err = mediaPlayer.error;
        console.log('[RECEIVER] media error: code=' + (err ? err.code : '?') + ' msg=' + (err ? err.message : '?'));
        mediaRetryCount++;
        if (mediaRetryCount <= MAX_MEDIA_RETRIES) {
          console.log('[RECEIVER] retrying in ' + (mediaRetryCount * 1000) + 'ms (attempt ' + (mediaRetryCount + 1) + ')');
          statusText.textContent = 'Retrying... (' + mediaRetryCount + '/' + MAX_MEDIA_RETRIES + ')';
          mediaRetryTimer = setTimeout(function () {
            // Append cache-buster to force a fresh request
            const sep = url.indexOf('?') >= 0 ? '&' : '?';
            const retryUrl = url + sep + 'retry=' + mediaRetryCount;
            mediaPlayer.src = retryUrl;
            mediaPlayer.load();
          }, mediaRetryCount * 1000);
        } else {
          console.log('[RECEIVER] all retries exhausted');
          statusText.textContent = 'Video Load Failed';
          sendStatus('idle');
        }
      };

      // Kick off load
      mediaPlayer.src = url;
      mediaPlayer.load();
    }

    function handleMediaControl(command, value) {
      switch (command) {
        case 'play':
          mediaPlayer.play();
          break;
        case 'pause':
          mediaPlayer.pause();
          break;
        case 'seek':
        case 'seekTo':
          mediaPlayer.currentTime = parseFloat(value) || 0;
          // Send updated status immediately after seek
          setTimeout(() => sendStatus(mediaPlayer.paused ? 'paused' : 'playing'), 100);
          break;
      }
    }

    function stopMediaCasting() {
      stopStatusReporting();
      mediaPlayer.pause();
      mediaPlayer.src = '';
      mediaPlayer.load();
      mediaPlayer.classList.add('hidden');
      mediaPlayer.style.display = 'none';
    }

    function stopAllMedia() {
      stopMediaCasting();
      stopImageCasting();
    }

    // ── Image display ─────────────────────────────────────────────────
    function showImageBlob(blob) {
      let url = URL.createObjectURL(blob);
      imageViewer.onload = () => URL.revokeObjectURL(url);
      imageViewer.src = url;
      splash.classList.add('hidden');
      videoPlayer.style.display = 'none';
      imageViewer.style.display = 'block';
      imageViewer.classList.remove('hidden');
      statusText.textContent = 'Showing Image';
    }

    // ── MJPEG mirroring ───────────────────────────────────────────────
    var isMirroringActive = false;
    var mjpegErrorTimer = null;

    function startMirroring(url) {
      cleanupMirroringConnection();
      cleanupImageCastingWS();
      videoPlayer.style.display = 'none';
      stopAllMedia();

      mjpegViewer.classList.remove('hidden');
      mjpegViewer.style.display = 'block';
      splash.classList.add('hidden');
      statusText.textContent = 'Connecting...';
      isMirroringActive = true;

      mjpegViewer.onerror = () => {
        if (isMirroringActive) {
          if (mjpegErrorTimer) clearTimeout(mjpegErrorTimer);
          mjpegErrorTimer = setTimeout(() => {
            if (isMirroringActive) { stopMirroring(); }
          }, 500);
        }
      };
      mjpegViewer.onload = () => {
        if (mjpegErrorTimer) { clearTimeout(mjpegErrorTimer); mjpegErrorTimer = null; }
        statusText.textContent = 'Mirroring Screen';
      };
      mjpegViewer.src = url;
    }

    function cleanupMirroringConnection() {
      isMirroringActive = false;
      if (mjpegErrorTimer) { clearTimeout(mjpegErrorTimer); mjpegErrorTimer = null; }
      mjpegViewer.onerror = null;
      mjpegViewer.onload = null;
      mjpegViewer.src = '';
      mjpegViewer.classList.add('hidden');
      mjpegViewer.style.display = 'none';
    }

    function stopMirroring() {
      cleanupMirroringConnection();
      cleanupImageCastingWS();
      stopAllMedia();
      videoPlayer.style.display = 'none';
      splash.classList.remove('hidden');
      statusText.textContent = 'Ready to receive';
    }

    // ── WebSocket image casting ───────────────────────────────────────
    let ws = null;

    function startImageCastingWS(url) {
      cleanupImageCastingWS();
      ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';
      ws.onopen = () => { statusText.textContent = 'Image Casting Active'; };
      ws.onmessage = (event) => {
        const data = new Uint8Array(event.data);
        if (data.length > 2 && data[0] === 0xFF && data[1] === 0xD8) {
          showImageBlob(new Blob([data], { type: 'image/jpeg' }));
        }
      };
      ws.onerror = () => statusText.textContent = 'Connection Error';
      ws.onclose = () => statusText.textContent = 'Disconnected';
    }

    function cleanupImageCastingWS() {
      if (ws) { ws.onclose = null; ws.close(); ws = null; }
    }

    function stopImageCasting() {
      imageViewer.classList.add('hidden');
      imageViewer.style.display = 'none';
      imageViewer.src = '';
    }

    // Start Cast Receiver
    const options = new cast.framework.CastReceiverOptions();
    options.disableIdleTimeout = true;
    options.maxInactivity = 86400;
    context.start(options);
  </script>
</body>

</html>
 
