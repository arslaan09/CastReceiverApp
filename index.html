<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Screen Mirror Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jmuxer@2.0.4/dist/jmuxer.min.js"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&display=swap');

    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%; height: 100%;
      background: #0a0c14;
      font-family: 'Inter', 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    /* ─── AMBIENT TV BACKGROUND ─── */
    #bg-canvas {
      position: absolute;
      inset: 0;
      background:
        radial-gradient(ellipse 80% 60% at 20% 50%, rgba(99,102,241,0.12) 0%, transparent 60%),
        radial-gradient(ellipse 60% 80% at 80% 50%, rgba(16,185,129,0.08) 0%, transparent 60%),
        #0a0c14;
      z-index: 0;
    }

    /* subtle grid texture */
    #bg-canvas::after {
      content: '';
      position: absolute;
      inset: 0;
      background-image:
        linear-gradient(rgba(99,102,241,0.04) 1px, transparent 1px),
        linear-gradient(90deg, rgba(99,102,241,0.04) 1px, transparent 1px);
      background-size: 60px 60px;
    }

    /* ─── SPLASH ─── */
    #splash {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 20;
    }

    .logo {
      width: 100px; height: 100px;
      background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      border-radius: 28px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 32px;
      box-shadow: 0 0 60px rgba(99,102,241,0.35), 0 20px 40px rgba(0,0,0,0.4);
      animation: logoPulse 3s ease-in-out infinite;
    }

    .logo svg { width: 52px; height: 52px; fill: white; }

    @keyframes logoPulse {
      0%,100% { box-shadow: 0 0 60px rgba(99,102,241,0.35), 0 20px 40px rgba(0,0,0,0.4); }
      50%      { box-shadow: 0 0 90px rgba(99,102,241,0.55), 0 20px 40px rgba(0,0,0,0.4); }
    }

    .app-title { font-size: 42px; font-weight: 700; letter-spacing: -0.5px; margin-bottom: 10px; }
    .app-sub   { font-size: 20px; opacity: 0.5; font-weight: 300; margin-bottom: 44px; }

    .status-pill {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 14px 32px;
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 100px;
      backdrop-filter: blur(16px);
    }

    .dot {
      width: 10px; height: 10px;
      background: #f59e0b;
      border-radius: 50%;
      animation: blink 1.8s ease-in-out infinite;
      flex-shrink: 0;
    }
    .dot.live { background: #10b981; animation: none; }

    @keyframes blink {
      0%,100% { opacity: 1; }
      50%      { opacity: 0.2; }
    }

    #statusText { font-size: 17px; font-weight: 400; opacity: 0.85; }

    /* ─────────────────────────────────────────────────────────────────────────
       PHONE FRAME — the key fix for Issue 1.

       Instead of a full-screen video element, we render a phone-shaped
       container centered on the TV canvas. The dark TV background remains
       visible on either side, giving a clean "device on a display" look.
    ───────────────────────────────────────────────────────────────────────── */
    #phone-wrapper {
      position: absolute;
      inset: 0;
      display: none;           /* flex when mirroring starts */
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    #phone-frame {
      position: relative;
      /* Drive size from height so it fits any TV safely */
      height: 92vh;
      /* iPhone-style portrait aspect ratio (390:844 ≈ 9:19.5) */
      aspect-ratio: 390 / 844;
      background: #000;
      border-radius: 48px;
      overflow: hidden;
      /* Layered shadow: bezel + drop shadow */
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.10),   /* glass edge highlight */
        0 0 0 10px #14141e,                  /* bezel body */
        0 0 0 12px rgba(255,255,255,0.06),   /* bezel outer rim */
        0 40px 100px rgba(0,0,0,0.75),       /* main drop shadow */
        0 80px 200px rgba(0,0,0,0.40);       /* wide ambient shadow */
      isolation: isolate;
    }

    /* Glass sheen — purely decorative, pointer-events off */
    #phone-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 48px;
      background: linear-gradient(
        140deg,
        rgba(255,255,255,0.09) 0%,
        transparent 35%,
        transparent 65%,
        rgba(255,255,255,0.04) 100%
      );
      z-index: 99;
      pointer-events: none;
    }

    /* Dynamic island / notch pill */
    #phone-notch {
      position: absolute;
      top: 16px;
      left: 50%;
      transform: translateX(-50%);
      width: 32%;
      height: 30px;
      background: #000;
      border-radius: 20px;
      z-index: 100;
      box-shadow: 0 0 0 1px rgba(255,255,255,0.07);
    }

    /* Video element fills the phone frame exactly */
    #video-player {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      /* cover = no black bars, fills the portrait frame perfectly
         since the encoder outputs portrait 1280×720 rotated by iOS */
      object-fit: cover;
      background: #000;
      border-radius: 48px;
      display: block;
    }

    /* ─── MEDIA PLAYER stays full-screen for video/audio cast ─── */
    #media-player {
      position: absolute;
      inset: 0;
      width: 100%; height: 100%;
      object-fit: contain;
      z-index: 15;
      background: black;
    }

    /* ─── IMAGE VIEWER — also inside a phone frame ─── */
    #image-frame-wrapper {
      position: absolute;
      inset: 0;
      display: none;
      justify-content: center;
      align-items: center;
      z-index: 10;
    }

    #image-phone-frame {
      position: relative;
      height: 92vh;
      aspect-ratio: 390 / 844;
      background: #000;
      border-radius: 48px;
      overflow: hidden;
      box-shadow:
        0 0 0 2px rgba(255,255,255,0.10),
        0 0 0 10px #14141e,
        0 0 0 12px rgba(255,255,255,0.06),
        0 40px 100px rgba(0,0,0,0.75),
        0 80px 200px rgba(0,0,0,0.40);
      isolation: isolate;
    }

    #image-phone-frame::before {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 48px;
      background: linear-gradient(
        140deg,
        rgba(255,255,255,0.09) 0%,
        transparent 35%,
        transparent 65%,
        rgba(255,255,255,0.04) 100%
      );
      z-index: 99;
      pointer-events: none;
    }

    #image-viewer {
      position: absolute;
      inset: 0;
      width: 100%; height: 100%;
      object-fit: cover;
      border-radius: 48px;
    }

    .hidden { display: none !important; }
  </style>
</head>

<body>

  <div id="bg-canvas"></div>

  <!-- Splash -->
  <div id="splash">
    <div class="logo">
      <svg viewBox="0 0 24 24">
        <path d="M21,3H3C1.89,3 1,3.89 1,5V17A2,2 0 0,0 3,19H8V21H16V19H21A2,2 0 0,0 23,17V5C23,3.89 22.1,3 21,3M21,17H3V5H21M16,11L9,15V7"/>
      </svg>
    </div>
    <div class="app-title">Screen Mirroring</div>
    <div class="app-sub" id="connectionMessage">Waiting for connection…</div>
    <div class="status-pill">
      <div class="dot" id="statusDot"></div>
      <span id="statusText">Ready to receive</span>
    </div>
  </div>

  <!-- Phone frame — holds the H.264 mirror video -->
  <div id="phone-wrapper">
    <div id="phone-frame">
      <div id="phone-notch"></div>
      <video id="video-player" autoplay playsinline muted></video>
    </div>
  </div>

  <!-- Full-screen player for video/audio cast -->
  <video id="media-player" class="hidden"></video>

  <!-- Phone frame for image casting -->
  <div id="image-frame-wrapper">
    <div id="image-phone-frame">
      <img id="image-viewer" alt="">
    </div>
  </div>

  <script>
    const context       = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();

    const splash            = document.getElementById('splash');
    const phoneWrapper      = document.getElementById('phone-wrapper');
    const videoPlayer       = document.getElementById('video-player');
    const mediaPlayer       = document.getElementById('media-player');
    const imageFrameWrapper = document.getElementById('image-frame-wrapper');
    const imageViewer       = document.getElementById('image-viewer');
    const connectionMessage = document.getElementById('connectionMessage');
    const statusText        = document.getElementById('statusText');
    const statusDot         = document.getElementById('statusDot');

    const NAMESPACE = 'urn:x-cast:com.tvmirror.screenmirror';

    let jmuxer           = null;
    let ws               = null;
    let liveEdgeInterval = null;
    let catchupCount     = 0;

    // ── Stall detection state ─────────────────────────────────────────────────
    // If videoPlayer.currentTime doesn't advance for ~3 seconds despite data
    // arriving, it means jmuxer ingested a bad SPS/PPS (the "WARNING - No SPS
    // cached" seen in the logs). We reinit jmuxer without closing the WebSocket
    // so the next IDR frame immediately recovers playback.
    let lastCurrentTime = -1;
    let stalledTicks    = 0;
    const STALL_LIMIT   = 12;   // 12 × 250ms = 3 seconds

    // ─────────────────────────────────────────────────────────────────────────
    context.addCustomMessageListener(NAMESPACE, (event) => {
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch (e) { return; }
      }

      if (data.type === 'CONNECTION_ESTABLISHED') {
        connectionMessage.textContent = 'Connected to ' + (data.deviceName || 'iOS Device');
        statusText.textContent = 'Connected';
        statusDot.classList.add('live');
      }

      if (data.type === 'START_MIRRORING') {
        stopImageCasting();
        if (data.streamUrl) startMirroring(data.streamUrl);
      }

      if (data.type === 'STOP_MIRRORING') stopMirroring();

      if (data.type === 'CAST_IMAGE_WS') {
        cleanupMirroring();
        stopMediaCasting();
        startMirroring(data.streamUrl);
        phoneWrapper.style.display = 'none';
        imageFrameWrapper.style.display = 'flex';
        statusText.textContent = 'Waiting for image…';
      }

      if (data.type === 'CAST_VIDEO') {
        cleanupMirroring();
        stopImageCasting();
        playVideo(data.videoUrl);
      }

      if (data.type === 'CAST_AUDIO') {
        cleanupMirroring();
        stopImageCasting();
        playVideo(data.audioUrl);
        statusText.textContent = 'Playing audio';
      }

      if (data.type === 'MEDIA_CONTROL') handleMediaControl(data.command, data.value);
    });

    // ── Media helpers ─────────────────────────────────────────────────────────

    function playVideo(url) {
      splash.classList.add('hidden');
      phoneWrapper.style.display = 'none';
      mediaPlayer.classList.remove('hidden');
      mediaPlayer.src = url;
      mediaPlayer.play();
      statusText.textContent = 'Playing video';
    }

    function handleMediaControl(command, value) {
      switch (command) {
        case 'play':   mediaPlayer.play();  break;
        case 'pause':  mediaPlayer.pause(); break;
        case 'seek':
        case 'seekTo': mediaPlayer.currentTime = value; break;
      }
    }

    function stopMediaCasting() {
      mediaPlayer.pause();
      mediaPlayer.src = '';
      mediaPlayer.classList.add('hidden');
    }

    function showImageBlob(blob) {
      const url = URL.createObjectURL(blob);
      imageViewer.onload = () => URL.revokeObjectURL(url);
      imageViewer.src = url;
      splash.classList.add('hidden');
      phoneWrapper.style.display = 'none';
      imageFrameWrapper.style.display = 'flex';
      statusText.textContent = 'Showing image';
    }

    function stopImageCasting() {
      imageFrameWrapper.style.display = 'none';
      imageViewer.src = '';
    }

    // ── JMuxer lifecycle ──────────────────────────────────────────────────────

    function createJmuxer() {
      if (jmuxer) {
        try { jmuxer.destroy(); } catch (_) {}
        jmuxer = null;
      }

      jmuxer = new JMuxer({
        node: 'video-player',
        mode: 'video',
        flushingTime: 0,     // flush every frame, no internal delay
        clearBuffer: true,   // discard stale buffer segments
        fps: 30,
        debug: false,
        onReady: () => {
          videoPlayer.play().catch(() => {});
        },
        onMissingData: () => {
          // No-op: let the video element hold its last frame during
          // brief network gaps rather than showing a black screen.
        }
      });
    }

    // ── Core mirroring ────────────────────────────────────────────────────────

    function startMirroring(url) {
      cleanupMirroring();

      catchupCount    = 0;
      stalledTicks    = 0;
      lastCurrentTime = -1;

      splash.classList.add('hidden');
      phoneWrapper.style.display = 'flex';
      statusText.textContent = 'Connecting…';

      createJmuxer();

      ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        statusText.textContent = 'Live';
        videoPlayer.play().catch(() => {});
        startLiveEdgeLoop();
      };

      ws.onmessage = (event) => {
        const data = new Uint8Array(event.data);

        // JPEG frame → show inside image phone frame
        if (data.length > 2 && data[0] === 0xFF && data[1] === 0xD8) {
          showImageBlob(new Blob([data], { type: 'image/jpeg' }));
          return;
        }

        // H.264 NAL — feed jmuxer; reinit on parse error
        if (jmuxer) {
          try {
            jmuxer.feed({ video: data });
          } catch (e) {
            console.warn('jmuxer parse error — reinitialising:', e);
            createJmuxer();
          }
        }
      };

      ws.onerror = () => { statusText.textContent = 'Connection error'; };
      ws.onclose = () => { statusText.textContent = 'Disconnected'; };
    }

    function startLiveEdgeLoop() {
      if (liveEdgeInterval) clearInterval(liveEdgeInterval);

      liveEdgeInterval = setInterval(() => {

        // ── Resume if paused ─────────────────────────────────────────────────
        if (videoPlayer.paused) {
          videoPlayer.play().catch(() => {});
        }

        const ct = videoPlayer.currentTime;

        // ── Stall detection ───────────────────────────────────────────────────
        // Triggered by stale SPS/PPS: jmuxer accepts data but video doesn't move.
        // Fix: destroy + recreate jmuxer; next IDR will restart cleanly.
        if (ct === lastCurrentTime && ct > 0) {
          stalledTicks++;
          if (stalledTicks >= STALL_LIMIT) {
            console.warn('Playback stalled — reinitialising jmuxer');
            createJmuxer();
            stalledTicks = 0;
          }
        } else {
          stalledTicks = 0;
        }
        lastCurrentTime = ct;

        // ── Live-edge catch-up (rate-only, no hard seeks) ─────────────────────
        // Hard seeks cause the decoder to flush its pipeline and wait for an IDR,
        // which is the main cause of the "fast burst then freeze" stutter.
        // Adjusting playbackRate is invisible to the viewer and never stalls.
        if (videoPlayer.buffered.length === 0) return;

        const end = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
        const lag = end - ct;

        if (lag > 3.5) {
          // Very far behind — only situation where a time-skip is justified.
          // Land 1.0s behind live edge so decoder has runway and won't starve.
          videoPlayer.currentTime = end - 1.0;
          videoPlayer.playbackRate = 1.0;
          catchupCount = 0;
        } else if (lag > 1.8) {
          videoPlayer.playbackRate = 1.07;
          catchupCount = 0;
        } else if (lag > 0.7) {
          videoPlayer.playbackRate = 1.03;
          catchupCount = 0;
        } else {
          catchupCount++;
          if (catchupCount >= 10) {       // ~2.5s stable → back to normal
            videoPlayer.playbackRate = 1.0;
          }
        }
      }, 250);
    }

    function cleanupMirroring() {
      if (liveEdgeInterval) { clearInterval(liveEdgeInterval); liveEdgeInterval = null; }
      if (ws)     { ws.onclose = null; ws.close(); ws = null; }
      if (jmuxer) { try { jmuxer.destroy(); } catch (_) {} jmuxer = null; }
      videoPlayer.playbackRate = 1.0;
      catchupCount    = 0;
      stalledTicks    = 0;
      lastCurrentTime = -1;
    }

    function stopMirroring() {
      cleanupMirroring();
      stopMediaCasting();
      stopImageCasting();
      phoneWrapper.style.display = 'none';
      splash.classList.remove('hidden');
      statusDot.classList.remove('live');
      statusText.textContent = 'Ready to receive';
    }

    // ── Cast receiver bootstrap ───────────────────────────────────────────────
    const options = new cast.framework.CastReceiverOptions();
    options.disableIdleTimeout = true;
    options.maxInactivity = 86400;
    context.start(options);
  </script>
</body>

</html>
