<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <title>Screen Mirror Receiver</title>
  <script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <script type="text/javascript" src="https://cdn.jsdelivr.net/npm/jmuxer@2.0.4/dist/jmuxer.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    html,
    body {
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
      font-family: 'Segoe UI', system-ui, sans-serif;
      overflow: hidden;
    }

    #splash {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      color: white;
      z-index: 10;
    }

    .logo {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      border-radius: 30px;
      display: flex;
      justify-content: center;
      align-items: center;
      margin-bottom: 40px;
      box-shadow: 0 20px 40px rgba(102, 126, 234, 0.3);
      animation: pulse 2s ease-in-out infinite;
    }

    .logo svg {
      width: 60px;
      height: 60px;
      fill: white;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
      }

      50% {
        transform: scale(1.05);
      }
    }

    .title {
      font-size: 48px;
      font-weight: 700;
      margin-bottom: 15px;
    }

    .subtitle {
      font-size: 24px;
      opacity: 0.8;
      margin-bottom: 50px;
    }

    .status-container {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 20px 40px;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 50px;
      backdrop-filter: blur(10px);
    }

    .status-dot {
      width: 12px;
      height: 12px;
      background: #fbbf24;
      border-radius: 50%;
      animation: blink 1.5s ease-in-out infinite;
    }

    .status-dot.connected {
      background: #4ade80;
    }

    @keyframes blink {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.4;
      }
    }

    .status-text {
      font-size: 20px;
    }

    #video-player {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
      background: black;
      display: none;
      z-index: 5;
    }

    .hidden {
      display: none !important;
    }
  </style>
</head>

<body>
  <div id="splash">
    <div class="logo">
      <svg viewBox="0 0 24 24">
        <path
          d="M21,3H3C1.89,3 1,3.89 1,5V17A2,2 0 0,0 3,19H8V21H16V19H21A2,2 0 0,0 23,17V5C23,3.89 22.1,3 21,3M21,17H3V5H21M16,11L9,15V7" />
      </svg>
    </div>
    <div class="title">Screen Mirroring -Miracast</div>
    <div class="subtitle" id="connectionMessage">Waiting for connection...</div>
    <div class="status-container">
      <div class="status-dot" id="statusDot"></div>
      <div class="status-text" id="statusText">Ready to receive</div>
    </div>
  </div>

  <video id="video-player" autoplay playsinline muted disableRemotePlayback></video>
  <video id="media-player" class="hidden"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 7; background: black;"></video>
  <img id="image-viewer" class="hidden"
    style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: contain; z-index: 6; background: black;">

  <script>
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();

    const splash = document.getElementById('splash');
    const videoPlayer = document.getElementById('video-player');
    const mediaPlayer = document.getElementById('media-player');
    const imageViewer = document.getElementById('image-viewer');
    const connectionMessage = document.getElementById('connectionMessage');
    const statusText = document.getElementById('statusText');
    const statusDot = document.getElementById('statusDot');

    const NAMESPACE = 'urn:x-cast:com.tvmirror.screenmirror';

    let jmuxer = null;
    let ws = null;
    let liveEdgeInterval = null;
    let currentStreamUrl = null;  // Track current URL for reconnection
    let reconnectAttempts = 0;
    let reconnectTimer = null;
    let wsPingInterval = null;
    const MAX_RECONNECT_ATTEMPTS = 50;  // Allow many reconnects for long sessions

    // Handle custom messages from sender
    context.addCustomMessageListener(NAMESPACE, (event) => {
      let data = event.data;
      if (typeof data === 'string') {
        try { data = JSON.parse(data); } catch (e) { return; }
      }

      if (data.type === 'CONNECTION_ESTABLISHED') {
        connectionMessage.textContent = 'Connected to ' + (data.deviceName || 'iOS Device');
        statusText.textContent = 'Connection established';
        statusDot.classList.add('connected');
      }

      if (data.type === 'START_MIRRORING') {
        stopImageCasting();
        if (data.streamUrl) startMirroring(data.streamUrl);
      }

      if (data.type === 'STOP_MIRRORING') stopMirroring();

      if (data.type === 'CAST_IMAGE_WS') {
        cleanupMirroringConnection();
        stopMediaCasting();
        startMirroring(data.streamUrl);
        videoPlayer.style.display = 'none';
        imageViewer.classList.remove('hidden');
        imageViewer.style.display = 'block';
        statusText.textContent = 'Waiting for Image...';
      }

      if (data.type === 'CAST_VIDEO') {
        cleanupMirroringConnection();
        stopImageCasting();
        playVideo(data.videoUrl);
      }

      if (data.type === 'CAST_AUDIO') {
        cleanupMirroringConnection();
        stopImageCasting();
        playVideo(data.audioUrl);
        statusText.textContent = 'Playing Audio';
      }

      if (data.type === 'MEDIA_CONTROL') handleMediaControl(data.command, data.value);
    });

    function playVideo(url) {
      splash.classList.add('hidden');
      mediaPlayer.classList.remove('hidden');
      mediaPlayer.style.display = 'block';
      mediaPlayer.src = url;
      mediaPlayer.play();
      statusText.textContent = 'Playing Video';
      videoPlayer.style.display = 'none';
    }

    function handleMediaControl(command, value) {
      if (!mediaPlayer) return;
      switch (command) {
        case 'play': mediaPlayer.play(); break;
        case 'pause': mediaPlayer.pause(); break;
        case 'seek':
        case 'seekTo':
          mediaPlayer.currentTime = value;
          break;
      }
    }

    function stopMediaCasting() {
      mediaPlayer.pause();
      mediaPlayer.src = "";
      mediaPlayer.classList.add('hidden');
      mediaPlayer.style.display = 'none';
    }

    function showImageBlob(blob) {
      let url = URL.createObjectURL(blob);
      imageViewer.onload = () => URL.revokeObjectURL(url);
      imageViewer.src = url;
      splash.classList.add('hidden');
      videoPlayer.style.display = 'none';
      imageViewer.style.display = 'block';
      imageViewer.classList.remove('hidden');
      statusText.textContent = 'Showing Image';
    }

    // =============================================
    // ULTRA LOW LATENCY MIRRORING WITH RECONNECTION
    // =============================================

    function startMirroring(url) {
      // CRITICAL FIX: If already mirroring with the SAME URL, don't destroy and rebuild.
      // This prevents the TV from blinking every time the sender re-sends START_MIRRORING
      // (e.g., on tap, foreground/background transitions, Cast session resume).
      if (currentStreamUrl === url && ws && ws.readyState === WebSocket.OPEN && jmuxer) {
        // Already connected to this stream - just ensure video is visible and playing
        videoPlayer.style.display = 'block';
        splash.classList.add('hidden');
        statusText.textContent = 'Mirroring Screen';
        videoPlayer.play().catch(() => { });
        return;
      }

      cleanupMirroringConnection();
      
      currentStreamUrl = url;  // Save for reconnection
      reconnectAttempts = 0;

      videoPlayer.style.display = 'block';
      splash.classList.add('hidden');
      statusText.textContent = 'Connecting...';

      // Create JMuxer with optimized low-latency settings
      jmuxer = new JMuxer({
        node: 'video-player',
        mode: 'video',
        flushingTime: 0,      // Immediate flush - no buffering delay
        clearBuffer: true,    // Aggressively clear old buffer data
        fps: 30,
        maxDelay: 0,          // No max delay tolerance
        debug: false,
        onReady: () => {
          videoPlayer.play().catch(() => { });
        },
        onError: (err) => {
          // JMuxer decode error - try to recover by seeking to live edge
          if (videoPlayer.buffered.length > 0) {
            const end = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
            videoPlayer.currentTime = end;
          }
        }
      });

      connectWebSocket(url);
    }

    function connectWebSocket(url) {
      if (ws) {
        ws.onclose = null;
        ws.onerror = null;
        ws.close();
        ws = null;
      }

      ws = new WebSocket(url);
      ws.binaryType = 'arraybuffer';

      ws.onopen = () => {
        statusText.textContent = 'Mirroring Screen';
        reconnectAttempts = 0;  // Reset on successful connect
        videoPlayer.play().catch(() => { });

        // Start live-edge maintenance every 200ms (balanced between latency and CPU usage)
        if (liveEdgeInterval) clearInterval(liveEdgeInterval);
        liveEdgeInterval = setInterval(() => {
          if (videoPlayer.buffered.length > 0) {
            const end = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
            const lag = end - videoPlayer.currentTime;
            // If more than 300ms behind live edge, jump forward
            // Too aggressive jumping (e.g., 150ms) causes visible stutters
            if (lag > 0.3) {
              videoPlayer.currentTime = end - 0.05;
            }
          }
          // Ensure video is always playing
          if (videoPlayer.paused) {
            videoPlayer.play().catch(() => { });
          }
        }, 200);

        // WebSocket keepalive ping every 15 seconds to prevent idle timeout
        if (wsPingInterval) clearInterval(wsPingInterval);
        wsPingInterval = setInterval(() => {
          if (ws && ws.readyState === WebSocket.OPEN) {
            try {
              ws.send(new Uint8Array([0x70, 0x69, 0x6E, 0x67])); // "ping" as binary
            } catch (e) { /* ignore */ }
          }
        }, 15000);
      };

      ws.onmessage = (event) => {
        const data = new Uint8Array(event.data);

        // JPEG image check (starts with FF D8)
        if (data.length > 2 && data[0] === 0xFF && data[1] === 0xD8) {
          showImageBlob(new Blob([data], { type: 'image/jpeg' }));
          return;
        }

        // Feed H.264 data to JMuxer immediately
        if (jmuxer) {
          jmuxer.feed({ video: data });
        }
      };

      ws.onerror = () => {
        statusText.textContent = 'Connection Error';
      };

      ws.onclose = () => {
        statusText.textContent = 'Reconnecting...';
        if (wsPingInterval) { clearInterval(wsPingInterval); wsPingInterval = null; }
        
        // Auto-reconnect with exponential backoff
        if (currentStreamUrl && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          reconnectAttempts++;
          // Backoff: 500ms, 1s, 2s, 3s, max 5s
          const delay = Math.min(5000, 500 * Math.pow(1.5, Math.min(reconnectAttempts - 1, 5)));
          reconnectTimer = setTimeout(() => {
            if (currentStreamUrl) {
              connectWebSocket(currentStreamUrl);
            }
          }, delay);
        } else {
          statusText.textContent = 'Disconnected';
        }
      };
    }

    // Handle video playback errors (stalled, decode errors)
    videoPlayer.addEventListener('error', () => {
      // Try to recover by seeking to live edge
      if (videoPlayer.buffered.length > 0) {
        const end = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
        videoPlayer.currentTime = end;
      }
    });

    videoPlayer.addEventListener('stalled', () => {
      // Video stalled - seek to latest available data
      if (videoPlayer.buffered.length > 0) {
        const end = videoPlayer.buffered.end(videoPlayer.buffered.length - 1);
        videoPlayer.currentTime = end;
        videoPlayer.play().catch(() => { });
      }
    });

    function stopImageCasting() {
      imageViewer.classList.add('hidden');
      imageViewer.style.display = 'none';
      imageViewer.src = "";
    }

    function cleanupMirroringConnection() {
      currentStreamUrl = null;  // Prevent reconnection
      reconnectAttempts = 0;
      
      if (reconnectTimer) {
        clearTimeout(reconnectTimer);
        reconnectTimer = null;
      }
      if (liveEdgeInterval) {
        clearInterval(liveEdgeInterval);
        liveEdgeInterval = null;
      }
      if (wsPingInterval) {
        clearInterval(wsPingInterval);
        wsPingInterval = null;
      }
      if (ws) {
        ws.onclose = null;  // Prevent reconnection on intentional close
        ws.onerror = null;
        ws.close();
        ws = null;
      }
      if (jmuxer) {
        jmuxer.destroy();
        jmuxer = null;
      }
    }

    function stopMirroring() {
      cleanupMirroringConnection();
      stopMediaCasting();
      stopImageCasting();
      videoPlayer.style.display = 'none';
      splash.classList.remove('hidden');
      statusText.textContent = 'Ready to receive';
    }

    // Start Cast Receiver
    const options = new cast.framework.CastReceiverOptions();
    options.disableIdleTimeout = true;
    options.maxInactivity = 86400;  // 24 hours - prevent auto-disconnect
    context.start(options);
  </script>
</body>

</html>
