import ReplayKit
import VideoToolbox
import Network

class SampleHandler: RPBroadcastSampleHandler {

    private var connection: NWConnection?
    private var session: VTCompressionSession?
    private let queue = DispatchQueue(label: "com.tvmirror.encoding.queue", qos: .userInteractive)
    private var isConnected = false
    
    private var connectionRetryCount = 0
    private let maxConnectionRetries = 100
    private var isReconnecting = false
    private var shouldKeepRunning = true
    
    // Drop frames when TCP send buffer backs up — prevents burst→stutter cycle
    private var pendingSendCount = 0
    private let maxPendingSends = 5
    
    private var width: Int32 = 720
    private var height: Int32 = 1280
    private var fps: Int32 = 30
    private var jpegQuality: Float = 0.6
    private var resizePercent: Int = 100
    private var mirroringMode = "tv"
    
    override func broadcastStarted(withSetupInfo setupInfo: [String : NSObject]?) {
        shouldKeepRunning = true
        connectionRetryCount = 0
        isReconnecting = false
        pendingSendCount = 0
        loadSettings()
        connectToHost()
        setupCompressionSession()
    }
    
    override func broadcastPaused() {}
    
    override func broadcastResumed() {
        if !isConnected && shouldKeepRunning { connectToHost() }
    }
    
    override func broadcastFinished() {
        shouldKeepRunning = false
        isConnected = false
        if let session = session {
            VTCompressionSessionCompleteFrames(session, untilPresentationTimeStamp: .invalid)
            VTCompressionSessionInvalidate(session)
            self.session = nil
        }
        connection?.cancel()
        connection = nil
    }
    
    override func processSampleBuffer(_ sampleBuffer: CMSampleBuffer, with sampleBufferType: RPSampleBufferType) {
        switch sampleBufferType {
        case .video:
            guard let session = session else { return }
            guard pendingSendCount <= maxPendingSends else { return }
            guard let imageBuffer = CMSampleBufferGetImageBuffer(sampleBuffer) else { return }
            let pts = CMSampleBufferGetPresentationTimeStamp(sampleBuffer)
            let duration = CMSampleBufferGetDuration(sampleBuffer)
            var flags: VTEncodeInfoFlags = []
            VTCompressionSessionEncodeFrame(session, imageBuffer: imageBuffer,
                presentationTimeStamp: pts, duration: duration,
                frameProperties: nil, sourceFrameRefcon: nil, infoFlagsOut: &flags)
        case .audioApp, .audioMic:
            break
        @unknown default:
            break
        }
    }
    
    private func connectToHost() {
        guard shouldKeepRunning, !isReconnecting else { return }
        isReconnecting = true
        pendingSendCount = 0
        connection?.cancel()
        connection = nil
        isConnected = false
        
        let appGroupID = "group.com.screen.mirroring.casting.miracast.airplay.screencast.TvMirror"
        let sharedDefaults = UserDefaults(suiteName: appGroupID)
        let hostIP = sharedDefaults?.string(forKey: "server_ip") ?? "127.0.0.1"
        self.mirroringMode = sharedDefaults?.string(forKey: "mirroring_mode") ?? "tv"
        if self.mirroringMode != "browser" && self.mirroringMode != "tv" && self.mirroringMode != "roku" {
            self.mirroringMode = "tv"
        }
        
        let tcpOptions = NWProtocolTCP.Options()
        tcpOptions.enableKeepalive = true
        tcpOptions.keepaliveIdle = 5
        tcpOptions.keepaliveCount = 3
        tcpOptions.keepaliveInterval = 5
        tcpOptions.connectionTimeout = 10
        tcpOptions.noDelay = true
        
        let params = NWParameters(tls: nil, tcp: tcpOptions)
        connection = NWConnection(host: NWEndpoint.Host(hostIP), port: NWEndpoint.Port(rawValue: 9000)!, using: params)
        
        connection?.stateUpdateHandler = { [weak self] state in
            guard let self = self else { return }
            switch state {
            case .ready:
                self.isConnected = true
                self.connectionRetryCount = 0
                self.isReconnecting = false
                self.pendingSendCount = 0
            case .failed(_):
                self.isConnected = false
                self.isReconnecting = false
                self.pendingSendCount = 0
                if self.shouldKeepRunning && self.connectionRetryCount < self.maxConnectionRetries {
                    self.connectionRetryCount += 1
                    let delay = min(5.0, 0.5 * pow(2.0, Double(min(self.connectionRetryCount - 1, 3))))
                    DispatchQueue.main.asyncAfter(deadline: .now() + delay) { self.connectToHost() }
                } else if self.connectionRetryCount >= self.maxConnectionRetries {
                    let err = NSError(domain: "com.tvmirror.extension", code: -2,
                        userInfo: [NSLocalizedDescriptionKey: "Connection failed after max retries"])
                    self.finishBroadcastWithError(err)
                }
            case .cancelled:
                self.isConnected = false
                self.isReconnecting = false
                self.pendingSendCount = 0
                if self.shouldKeepRunning {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 1.0) { self.connectToHost() }
                }
            default: break
            }
        }
        connection?.start(queue: queue)
    }
    
    private func loadSettings() {
        let appGroupID = "group.com.screen.mirroring.casting.miracast.airplay.screencast.TvMirror"
        let defaults = UserDefaults(suiteName: appGroupID)
        self.mirroringMode = defaults?.string(forKey: "mirroring_mode") ?? "tv"
        
        let screen = UIScreen.main.bounds.size
        let nativeWidth = Int32(screen.width * UIScreen.main.scale)
        let nativeHeight = Int32(screen.height * UIScreen.main.scale)
        
        if mirroringMode == "browser" {
            let fpsLimit = defaults?.integer(forKey: "browserMirror_limitFPS") ?? 30
            self.fps = Int32(fpsLimit > 0 ? fpsLimit : 30)
            let quality = defaults?.double(forKey: "browserMirror_jpegCompressionQuality") ?? 60.0
            self.jpegQuality = quality > 1.0 ? Float(quality / 100.0) : Float(quality)
            let resize = defaults?.integer(forKey: "browserMirror_resizeImagePercent") ?? 80
            self.resizePercent = (resize > 0 && resize <= 100) ? resize : 80
            let scaleFactor = Double(resizePercent) / 100.0
            self.width = Int32(Double(nativeWidth) * scaleFactor)
            self.height = Int32(Double(nativeHeight) * scaleFactor)
            if self.width % 2 != 0 { self.width += 1 }
            if self.height % 2 != 0 { self.height += 1 }
        } else if mirroringMode == "roku" {
            self.width = 480
            let ratio = Double(nativeHeight) / Double(nativeWidth)
            self.height = Int32(Double(self.width) * ratio)
            if self.width % 2 != 0 { self.width += 1 }
            if self.height % 2 != 0 { self.height += 1 }
            self.fps = 30
            self.jpegQuality = 0.35
        } else {
            self.width = 720
            self.height = 1280
            self.fps = 30
        }
    }
    
    private func setupCompressionSession() {
        // Tear down any existing session first to prevent double-init
        // (which would create a session without CAVLC on the second call)
        if let existing = session {
            VTCompressionSessionCompleteFrames(existing, untilPresentationTimeStamp: .invalid)
            VTCompressionSessionInvalidate(existing)
            self.session = nil
        }
        
        let codecType: CMVideoCodecType = (mirroringMode == "browser" || mirroringMode == "roku")
            ? kCMVideoCodecType_JPEG : kCMVideoCodecType_H264
        
        let status = VTCompressionSessionCreate(
            allocator: kCFAllocatorDefault, width: width, height: height, codecType: codecType,
            encoderSpecification: nil, imageBufferAttributes: nil, compressedDataAllocator: nil,
            outputCallback: compressionCallback,
            refcon: UnsafeMutableRawPointer(Unmanaged.passUnretained(self).toOpaque()),
            compressionSessionOut: &session)
        
        guard status == noErr, let session = session else { return }
        
        VTSessionSetProperty(session, key: kVTCompressionPropertyKey_RealTime, value: kCFBooleanTrue)
        VTSessionSetProperty(session, key: kVTCompressionPropertyKey_ExpectedFrameRate, value: fps as CFNumber)
        
        if codecType == kCMVideoCodecType_H264 {
            // ── FORCE TRUE BASELINE PROFILE ──────────────────────────────────
            // CAVLC is a Baseline-only entropy mode — the hardware encoder
            // physically cannot produce valid CAVLC-coded H.264 in Main/High.
            // This is the only reliable way to enforce Baseline on iOS hardware.
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_ProfileLevel,
                value: kVTProfileLevel_H264_Baseline_3_1)
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_H264EntropyMode,
                value: kVTH264EntropyMode_CAVLC)
            
            // No B-frames: mandatory for Baseline, also eliminates decode delay
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_AllowFrameReordering,
                value: kCFBooleanFalse)
            
            // ── BITRATE: 700Kbps ─────────────────────────────────────────────
            // 1.2Mbps caused encoder to fight against its own rate control,
            // producing burst spikes at IDR boundaries. 700Kbps is the sweet
            // spot for 720p screen content over WiFi — smooth and low-latency.
            // NO DataRateLimits: that property fights the AverageBitRate setting
            // and causes the encoder to stall then dump large IDR bursts.
            let avgBitrate: Int32 = 700_000
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_AverageBitRate,
                value: avgBitrate as CFNumber)
            
            // ── KEYFRAME: every 4s ───────────────────────────────────────────
            // With CAVLC Baseline, IDR frames are ~5KB — negligible burst.
            // 4s balances recovery speed vs steady-state traffic smoothness.
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_MaxKeyFrameInterval,
                value: (self.fps * 4) as CFNumber)
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_MaxKeyFrameIntervalDuration,
                value: 4.0 as CFNumber)
        } else {
            VTSessionSetProperty(session, key: kVTCompressionPropertyKey_Quality, value: jpegQuality as CFNumber)
        }
        
        if #available(iOS 15.0, *) {
            VTSessionSetProperty(session,
                key: kVTCompressionPropertyKey_PrioritizeEncodingSpeedOverQuality,
                value: kCFBooleanTrue)
        }
        
        VTCompressionSessionPrepareToEncodeFrames(session)
    }
}

private func compressionCallback(
    outputCallbackRefCon: UnsafeMutableRawPointer?,
    sourceFrameRefCon: UnsafeMutableRawPointer?,
    status: OSStatus,
    infoFlags: VTEncodeInfoFlags,
    sampleBuffer: CMSampleBuffer?
) {
    guard status == noErr, let sampleBuffer = sampleBuffer, let refCon = outputCallbackRefCon else { return }
    Unmanaged<SampleHandler>.fromOpaque(refCon).takeUnretainedValue().handleEncodedFrame(sampleBuffer: sampleBuffer)
}

extension SampleHandler {
    func handleEncodedFrame(sampleBuffer: CMSampleBuffer) {
        guard let dataBuffer = CMSampleBufferGetDataBuffer(sampleBuffer) else { return }
        
        if mirroringMode == "browser" || mirroringMode == "roku" {
            var lengthAtOffset: Int = 0
            var totalLength: Int = 0
            var dataPointer: UnsafeMutablePointer<Int8>?
            guard CMBlockBufferGetDataPointer(dataBuffer, atOffset: 0, lengthAtOffsetOut: &lengthAtOffset, totalLengthOut: &totalLength, dataPointerOut: &dataPointer) == noErr else { return }
            sendFrameWithLength(Data(bytes: dataPointer!, count: totalLength))
            return
        }
        
        var frameData = Data()
        
        if let attachments = CMSampleBufferGetSampleAttachmentsArray(sampleBuffer, createIfNecessary: true) as? [[CFString: Any]],
           let attachment = attachments.first {
            let notSync = attachment[kCMSampleAttachmentKey_NotSync] as? Bool ?? false
            if !notSync {
                if let paramData = getSPSPPS(from: sampleBuffer) { frameData.append(paramData) }
            }
        }
        
        var lengthAtOffset: Int = 0
        var totalLength: Int = 0
        var dataPointer: UnsafeMutablePointer<Int8>?
        guard CMBlockBufferGetDataPointer(dataBuffer, atOffset: 0, lengthAtOffsetOut: &lengthAtOffset, totalLengthOut: &totalLength, dataPointerOut: &dataPointer) == noErr else { return }
        
        var offset = 0
        while offset < totalLength - 4 {
            var naluLength: UInt32 = 0
            memcpy(&naluLength, dataPointer! + offset, 4)
            naluLength = CFSwapInt32BigToHost(naluLength)
            offset += 4
            frameData.append(contentsOf: [0x00, 0x00, 0x00, 0x01])
            frameData.append(Data(bytes: dataPointer! + offset, count: Int(naluLength)))
            offset += Int(naluLength)
        }
        
        sendFrameWithLength(frameData)
    }
    
    private func sendFrameWithLength(_ data: Data) {
        guard shouldKeepRunning else { return }
        guard isConnected, let connection = connection else {
            if !isReconnecting && shouldKeepRunning { connectToHost() }
            return
        }
        
        pendingSendCount += 1
        var length = UInt32(data.count).bigEndian
        var packet = Data(capacity: 4 + data.count)
        packet.append(Data(bytes: &length, count: 4))
        packet.append(data)
        
        connection.send(content: packet, completion: .contentProcessed({ [weak self] error in
            guard let self = self else { return }
            self.pendingSendCount = max(0, self.pendingSendCount - 1)
            if let _ = error {
                self.isConnected = false
                if self.shouldKeepRunning && !self.isReconnecting { self.connectToHost() }
            }
        }))
    }
    
    private func getSPSPPS(from sampleBuffer: CMSampleBuffer) -> Data? {
        guard let formatDescription = CMSampleBufferGetFormatDescription(sampleBuffer) else { return nil }
        var parameterSetCount = 0
        CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescription, parameterSetIndex: 0,
            parameterSetPointerOut: nil, parameterSetSizeOut: nil,
            parameterSetCountOut: &parameterSetCount, nalUnitHeaderLengthOut: nil)
        
        var result = Data()
        for i in 0..<parameterSetCount {
            var ptr: UnsafePointer<UInt8>?
            var size: Int = 0
            CMVideoFormatDescriptionGetH264ParameterSetAtIndex(formatDescription, parameterSetIndex: i,
                parameterSetPointerOut: &ptr, parameterSetSizeOut: &size,
                parameterSetCountOut: nil, nalUnitHeaderLengthOut: nil)
            if let p = ptr {
                result.append(contentsOf: [0x00, 0x00, 0x00, 0x01])
                result.append(contentsOf: UnsafeBufferPointer(start: p, count: size))
            }
        }
        return result.isEmpty ? nil : result
    }
}
